<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimCityé¢¨ã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #2c3e50;
            color: white;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 200px;
            background-color: #34495e;
            padding: 20px;
            border-right: 2px solid #1a252f;
        }
        
        .building-button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .building-button:hover {
            background-color: #2980b9;
        }
        
        .building-button.active {
            background-color: #e74c3c;
        }
        
        .game-area {
            flex: 1;
            position: relative;
            overflow-y: auto;
            height: 100vh;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(40, 20px);
            grid-template-rows: repeat(30, 20px);
            gap: 1px;
            padding: 20px;
            background-color: #27ae60;
            overflow: auto;
            max-height: calc(100vh - 40px);
        }
        
        .cell {
            width: 20px;
            height: 20px;
            background-color: #2ecc71;
            border: 1px solid #27ae60;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .cell:hover {
            background-color: #58d68d;
        }
        
        .cell.residential {
            background-color: #f39c12;
        }
        
        .cell.commercial {
            background-color: #9b59b6;
        }
        
        .cell.road {
            background-color: #7f8c8d;
        }
        
        .cell.rail {
            background-color: #34495e;
        }
        
        .cell.highway {
            background-color: #2c3e50;
        }
        
        .cell.crossing {
            background-color: #e67e22;
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-size: 18px;
        }
        
        h2 {
            margin: 20px 0 10px 0;
            font-size: 16px;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: #34495e;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 400px;
            color: white;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: white;
        }
        
        .save-slot {
            background-color: #2c3e50;
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid #34495e;
        }
        
        .save-slot:hover {
            border-color: #3498db;
        }
        
        .save-slot.occupied {
            border-color: #27ae60;
        }
        
        .slot-info {
            font-size: 12px;
            color: #bdc3c7;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>SimCityé¢¨ã‚²ãƒ¼ãƒ </h1>
            
            <div style="background-color: #27ae60; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px;">ğŸ’° ç¨åæƒ…å ±</h3>
                <div style="font-size: 16px; font-weight: bold;">Â¥<span id="taxRevenue">0</span>/æœˆ</div>
                <div style="font-size: 12px; margin-top: 5px;">å»ºç‰©æ•°: <span id="buildingCount">0</span></div>
                <div style="font-size: 12px;">é«˜é€Ÿé“è·¯: <span id="highwayCount">0</span>/20</div>
                <div style="font-size: 12px;">è¸åˆ‡: <span id="crossingCount">0</span>/10</div>
                <div style="font-size: 12px;">äº¤é€šç¶²: <span id="clusterCount">0</span>ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼</div>
            </div>
            
            
            <h2>å»ºç‰©</h2>
            <button class="building-button" onclick="selectBuilding('residential')">ä½å®… ğŸ </button>
            <button class="building-button" onclick="selectBuilding('commercial')">å•†æ¥­æ–½è¨­ ğŸ¢</button>
            
            <h2>ã‚¤ãƒ³ãƒ•ãƒ©</h2>
            <button class="building-button" onclick="selectBuilding('road')">é“è·¯ ğŸ›£ï¸</button>
            <button class="building-button" onclick="selectBuilding('highway')">é«˜é€Ÿé“è·¯ ğŸ›¤ï¸</button>
            <button class="building-button" onclick="selectBuilding('rail')">é‰„é“ ğŸš‚</button>
            <button class="building-button" onclick="selectBuilding('crossing')">è¸åˆ‡ âš¡</button>
            
            <h2>æ“ä½œ</h2>
            <button class="building-button" onclick="clearSelection()" style="background-color: #e74c3c;">é¸æŠè§£é™¤</button>
            
            <h2>ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰</h2>
            <button class="building-button" onclick="showSaveDialog()" style="background-color: #27ae60;">ã‚»ãƒ¼ãƒ– ğŸ’¾</button>
            <button class="building-button" onclick="showLoadDialog()" style="background-color: #f39c12;">ãƒ­ãƒ¼ãƒ‰ ğŸ“</button>
            
            <h2>è‡ªå‹•ãƒ—ãƒ¬ã‚¤</h2>
            <button id="autoPlayBtn" class="building-button" onclick="toggleAutoPlay()" style="background-color: #8e44ad;">è‡ªå‹•ãƒ—ãƒ¬ã‚¤é–‹å§‹ ğŸ¤–</button>
            <div style="font-size: 12px; margin-top: 5px;">åå¾©å›æ•°: <span id="iterationCount">0</span>/50000</div>
            <div style="font-size: 12px;">æ¸©åº¦: <span id="temperature">100</span></div>
        </div>
        
        <div class="game-area">
            <div class="grid" id="gameGrid">
            </div>
            
            <div style="background-color: #34495e; margin: 20px; padding: 20px; border-radius: 10px;">
                <h3 style="margin: 0 0 15px 0; font-size: 18px; color: white;">ğŸ“ˆ ç¨åæ¨ç§»ã‚°ãƒ©ãƒ•</h3>
                <canvas id="taxChart" width="800" height="300" style="background-color: #2c3e50; border-radius: 5px; border: 1px solid #1a252f;"></canvas>
            </div>
            
            <div style="background-color: #34495e; margin: 20px; padding: 20px; border-radius: 10px;">
                <h3 style="margin: 0 0 15px 0; font-size: 18px; color: white;">ğŸ  å»ºç‰©æ•°æ¨ç§»ã‚°ãƒ©ãƒ•</h3>
                <canvas id="buildingChart" width="800" height="300" style="background-color: #2c3e50; border-radius: 5px; border: 1px solid #1a252f;"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Save Modal -->
    <div id="saveModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSaveDialog()">&times;</span>
            <h3>éƒ½å¸‚ã‚’ã‚»ãƒ¼ãƒ–</h3>
            <div id="saveSlots"></div>
        </div>
    </div>
    
    <!-- Load Modal -->
    <div id="loadModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeLoadDialog()">&times;</span>
            <h3>éƒ½å¸‚ã‚’ãƒ­ãƒ¼ãƒ‰</h3>
            <div id="loadSlots"></div>
        </div>
    </div>

    <script>
        let selectedBuilding = null;
        let grid = [];
        let totalTaxRevenue = 0;
        let buildingCount = 0;
        let highwayCount = 0;
        let crossingCount = 0;
        let autoPlayActive = false;
        let autoPlayInterval = null;
        let iterationCount = 0;
        let taxHistory = [];
        let buildingHistory = [];
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 30;
        const MAX_HIGHWAYS = 20;
        const MAX_CROSSINGS = 10;
        const MAX_ITERATIONS = 50000;
        const INITIAL_TEMPERATURE = 100;
        const FINAL_TEMPERATURE = 10;
        
        const buildingTypes = ['residential', 'commercial', 'road', 'highway', 'rail', 'crossing', null];
        
        const baseTaxRates = {
            residential: 150,
            commercial: 50
        };
        
        const maintenanceCosts = {
            road: 50,
            highway: 80,
            rail: 50,
            crossing: 80
        };
        
        const accessRanges = {
            road: 10,
            highway: 15,
            rail: 20,
            crossing: 25
        };
        
        const movementCosts = {
            road: 1.0,
            highway: 0.5,    // é«˜é€Ÿé“è·¯ã¯æ—©ã„
            rail: 0.3,       // é‰„é“ã¯ã‚‚ã£ã¨æ—©ã„
            crossing: 0.2,   // è¸åˆ‡ã¯æœ€ã‚‚åŠ¹ç‡çš„
            residential: 1.0,
            commercial: 1.0
        };

        function initializeGrid() {
            const gameGrid = document.getElementById('gameGrid');
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    grid[y][x] = null;
                    
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.onclick = () => placeBuilding(x, y);
                    
                    gameGrid.appendChild(cell);
                }
            }
        }

        function selectBuilding(buildingType) {
            selectedBuilding = buildingType;
            
            document.querySelectorAll('.building-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
        }

        function clearSelection() {
            selectedBuilding = null;
            document.querySelectorAll('.building-button').forEach(btn => {
                btn.classList.remove('active');
            });
        }

        function placeBuilding(x, y) {
            if (!selectedBuilding) return;
            
            if (selectedBuilding === 'highway' && highwayCount >= MAX_HIGHWAYS) {
                alert('é«˜é€Ÿé“è·¯ã¯æœ€å¤§20ãƒã‚¹ã¾ã§ã—ã‹å»ºè¨­ã§ãã¾ã›ã‚“ï¼');
                return;
            }
            
            if (selectedBuilding === 'crossing' && crossingCount >= MAX_CROSSINGS) {
                alert('è¸åˆ‡ã¯æœ€å¤§10ãƒã‚¹ã¾ã§ã—ã‹å»ºè¨­ã§ãã¾ã›ã‚“ï¼');
                return;
            }
            
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            
            if (grid[y][x] === 'highway') {
                highwayCount--;
            }
            if (grid[y][x] === 'crossing') {
                crossingCount--;
            }
            
            grid[y][x] = selectedBuilding;
            cell.className = `cell ${selectedBuilding}`;
            
            if (selectedBuilding === 'highway') {
                highwayCount++;
            }
            if (selectedBuilding === 'crossing') {
                crossingCount++;
            }
            
            const symbols = {
                residential: 'ğŸ ',
                commercial: 'ğŸ¢',
                road: 'â€”',
                rail: 'â•',
                highway: 'â”',
                crossing: 'â•¬'
            };
            
            cell.textContent = symbols[selectedBuilding] || '';
            
            calculateTaxRevenue();
        }
        
        function calculateTaxRevenue() {
            totalTaxRevenue = 0;
            buildingCount = 0;
            let residentialCount = 0;
            let commercialCount = 0;
            
            // ã¾ãšä½å®…ã¨å•†æ¥­æ–½è¨­ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const buildingType = grid[y][x];
                    if (buildingType === 'residential') {
                        residentialCount++;
                    } else if (buildingType === 'commercial') {
                        commercialCount++;
                    }
                }
            }
            
            buildingCount = residentialCount + commercialCount;
            
            // å•†æ¥­æ–½è¨­ã®ä¾›çµ¦ãƒãƒ©ãƒ³ã‚¹ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆä½å®…5è»’:å•†æ¥­1è»’ãŒç†æƒ³ï¼‰
            const optimalRatio = 0.2; // å•†æ¥­/ä½å®…ã®ç†æƒ³æ¯”ç‡ï¼ˆ1/5ï¼‰
            const currentRatio = residentialCount > 0 ? commercialCount / residentialCount : 0;
            let supplyBalanceFactor = 1.0;
            
            if (currentRatio > optimalRatio) {
                // éå‰°ä¾›çµ¦æ™‚ã®ãƒšãƒŠãƒ«ãƒ†ã‚£
                if (currentRatio <= 0.4) {
                    // æ¯”ç‡0.2-0.4: ç·šå½¢ã«0.8ã¾ã§æ¸›å°‘
                    supplyBalanceFactor = 1.0 - (currentRatio - optimalRatio) * 1.0;
                } else if (currentRatio <= 0.6) {
                    // æ¯”ç‡0.4-0.6: 0.8ã‹ã‚‰0.5ã¾ã§æ¸›å°‘
                    supplyBalanceFactor = 0.8 - (currentRatio - 0.4) * 1.5;
                } else {
                    // æ¯”ç‡0.6ä»¥ä¸Š: 0.3ã«å›ºå®š
                    supplyBalanceFactor = 0.3;
                }
            }
            
            // äº¤é€šã‚¤ãƒ³ãƒ•ãƒ©ã®é€£çµæ€§ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’è¨ˆç®—
            const infraClusters = getInfrastructureClusters();
            let connectivityFactor = 1.0;
            
            if (infraClusters > 1) {
                // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°ãŒå¤šã„ã»ã©ãƒšãƒŠãƒ«ãƒ†ã‚£ãŒå¤§ãããªã‚‹ï¼ˆé€£ç¶šçš„ã§ç·©ã‚„ã‹ï¼‰
                // ä¿‚æ•° = 1 / (1 + 0.1 * (clusters - 1))
                // 1ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼: 1.0, 2ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼: 0.91, 5ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼: 0.71, 10ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼: 0.53
                connectivityFactor = 1.0 / (1.0 + 0.1 * (infraClusters - 1));
            }
            
            // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚µã‚¤ã‚ºãƒãƒƒãƒ—ã‚’äº‹å‰è¨ˆç®—
            const roadClusterSizes = getClusterSizeMap(['road', 'highway', 'crossing']);
            const railClusterSizes = getClusterSizeMap(['rail', 'crossing']);
            
            // ç¨åè¨ˆç®—ã¨ç¶­æŒè²»è¨ˆç®—
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const buildingType = grid[y][x];
                    if (buildingType === 'residential') {
                        totalTaxRevenue += baseTaxRates.residential;
                    } else if (buildingType === 'commercial') {
                        let accessibleResidential = getAccessibleResidential(x, y);
                        if (accessibleResidential > 0) {
                            const baseTax = baseTaxRates.commercial + (accessibleResidential * 50);
                            totalTaxRevenue += baseTax * supplyBalanceFactor * connectivityFactor;
                        }
                    } else if (maintenanceCosts[buildingType]) {
                        // ç¶­æŒè²»è¨ˆç®—
                        let clusterSize = 1;
                        
                        // é“è·¯ç³»ã®å»ºç‰©
                        if (['road', 'highway'].includes(buildingType)) {
                            clusterSize = roadClusterSizes[y][x];
                        } 
                        // é‰„é“ç³»ã®å»ºç‰©
                        else if (buildingType === 'rail') {
                            clusterSize = railClusterSizes[y][x];
                        }
                        // è¸åˆ‡ã¯ä¸¡æ–¹ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚µã‚¤ã‚ºã®å¹³å‡
                        else if (buildingType === 'crossing') {
                            const roadSize = roadClusterSizes[y][x];
                            const railSize = railClusterSizes[y][x];
                            clusterSize = (roadSize + railSize) / 2;
                        }
                        
                        // ç¶­æŒè²»å‰²å¼•ä¿‚æ•°è¨ˆç®—ï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚µã‚¤ã‚ºã®é€†æ•°ã«æ¯”ä¾‹ã€é€£ç¶šçš„å¤‰åŒ–ï¼‰
                        // ä¿‚æ•° = 1/clusterSize ï¼ˆæœ€å°0.2ã§ä¸‹é™è¨­å®šï¼‰
                        const discountFactor = Math.max(0.2, 1.0 / clusterSize);
                        const maintenance = maintenanceCosts[buildingType] * discountFactor;
                        
                        totalTaxRevenue -= maintenance;
                    }
                }
            }
            
            updateTaxDisplay();
        }
        
        function getInfrastructureClusters() {
            // é“è·¯ç³»ã¨é‰„é“ç³»ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°ã‚’åˆ¥ã€…ã«è¨ˆç®—
            const roadClusters = getClustersByType(['road', 'highway', 'crossing']);
            const railClusters = getClustersByType(['rail', 'crossing']);
            
            // ç›¸åŠ å¹³å‡ã‚’è¿”ã™ï¼ˆã‚¤ãƒ³ãƒ•ãƒ©ãŒãªã„å ´åˆã¯0ã¨ã—ã¦æ‰±ã†ï¼‰
            let totalClusters = 0;
            let networkCount = 0;
            
            if (roadClusters > 0) {
                totalClusters += roadClusters;
                networkCount++;
            }
            
            if (railClusters > 0) {
                totalClusters += railClusters;
                networkCount++;
            }
            
            return networkCount > 0 ? totalClusters / networkCount : 0;
        }
        
        function getClustersByType(allowedTypes) {
            // æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®ã‚¤ãƒ³ãƒ•ãƒ©ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°ã‚’è¨ˆç®—
            const visited = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(false));
            let clusterCount = 0;
            
            function isAllowedInfrastructure(buildingType) {
                return allowedTypes.includes(buildingType);
            }
            
            function dfs(x, y) {
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT || 
                    visited[y][x] || !isAllowedInfrastructure(grid[y][x])) {
                    return;
                }
                
                visited[y][x] = true;
                
                // éš£æ¥ã™ã‚‹4æ–¹å‘ã‚’æ¢ç´¢
                dfs(x + 1, y);
                dfs(x - 1, y);
                dfs(x, y + 1);
                dfs(x, y - 1);
            }
            
            // æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®äº¤é€šã‚¤ãƒ³ãƒ•ãƒ©ã‚»ãƒ«ã‚’æ¢ç´¢ã—ã¦ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (isAllowedInfrastructure(grid[y][x]) && !visited[y][x]) {
                        dfs(x, y);
                        clusterCount++;
                    }
                }
            }
            
            return clusterCount;
        }
        
        function getClusterSizeMap(allowedTypes) {
            // å„ã‚»ãƒ«ãŒå±ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¨˜éŒ²ã™ã‚‹ãƒãƒƒãƒ—ã‚’ä½œæˆ
            const sizeMap = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
            const visited = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(false));
            
            function isAllowedInfrastructure(buildingType) {
                return allowedTypes.includes(buildingType);
            }
            
            function dfsWithSize(x, y, clusterCells) {
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT || 
                    visited[y][x] || !isAllowedInfrastructure(grid[y][x])) {
                    return;
                }
                
                visited[y][x] = true;
                clusterCells.push({x, y});
                
                // éš£æ¥ã™ã‚‹4æ–¹å‘ã‚’æ¢ç´¢
                dfsWithSize(x + 1, y, clusterCells);
                dfsWithSize(x - 1, y, clusterCells);
                dfsWithSize(x, y + 1, clusterCells);
                dfsWithSize(x, y - 1, clusterCells);
            }
            
            // å„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚’æ¢ç´¢ã—ã¦ã‚µã‚¤ã‚ºã‚’è¨˜éŒ²
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (isAllowedInfrastructure(grid[y][x]) && !visited[y][x]) {
                        const clusterCells = [];
                        dfsWithSize(x, y, clusterCells);
                        
                        // ã“ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã®å…¨ã‚»ãƒ«ã«ã‚µã‚¤ã‚ºã‚’è¨˜éŒ²
                        const clusterSize = clusterCells.length;
                        for (const cell of clusterCells) {
                            sizeMap[cell.y][cell.x] = clusterSize;
                        }
                    }
                }
            }
            
            return sizeMap;
        }
        
        
        let distanceCache = new Map();
        let cacheValidGrid = null;
        
        function getAccessibleResidential(commercialX, commercialY) {
            const maxRange = getMaxAccessRange(commercialX, commercialY);
            
            // ã‚¤ãƒ³ãƒ•ãƒ©ãªã—ï¼ˆç¯„å›²1ï¼‰ã®å ´åˆã¯éš£æ¥ä½å®…ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆ
            if (maxRange === 1) {
                let accessibleCount = 0;
                const adjacentCells = [
                    {x: commercialX-1, y: commercialY}, {x: commercialX+1, y: commercialY},
                    {x: commercialX, y: commercialY-1}, {x: commercialX, y: commercialY+1}
                ];
                
                for (let cell of adjacentCells) {
                    if (cell.x >= 0 && cell.x < GRID_WIDTH && cell.y >= 0 && cell.y < GRID_HEIGHT) {
                        if (grid[cell.y][cell.x] === 'residential') {
                            accessibleCount++;
                        }
                    }
                }
                
                return accessibleCount;
            }
            
            // ã‚¤ãƒ³ãƒ•ãƒ©ã‚ã‚Šã®å ´åˆã¯å¾“æ¥é€šã‚ŠçµŒè·¯æ¢ç´¢
            const distances = getDistanceMap(commercialX, commercialY, maxRange);
            
            let accessibleCount = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === 'residential' && distances[y][x] !== -1 && distances[y][x] <= maxRange) {
                        accessibleCount++;
                    }
                }
            }
            
            return accessibleCount;
        }
        
        function getDistanceMap(startX, startY, maxRange) {
            const cacheKey = `${startX},${startY},${maxRange}`;
            
            // ã‚°ãƒªãƒƒãƒ‰ãŒå¤‰æ›´ã•ã‚Œã¦ã„ãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
            if (cacheValidGrid !== JSON.stringify(grid)) {
                distanceCache.clear();
                cacheValidGrid = JSON.stringify(grid);
            }
            
            if (distanceCache.has(cacheKey)) {
                return distanceCache.get(cacheKey);
            }
            
            const distances = calculateDistanceMapDP(startX, startY, maxRange);
            distanceCache.set(cacheKey, distances);
            return distances;
        }
        
        function calculateDistanceMapDP(startX, startY, maxRange) {
            // å‹•çš„è¨ˆç”»æ³•ã§è·é›¢ãƒãƒƒãƒ—ã‚’è¨ˆç®—
            const distances = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(-1));
            const queue = [{x: startX, y: startY, dist: 0}];
            distances[startY][startX] = 0;
            
            let queueIndex = 0;
            while (queueIndex < queue.length) {
                const current = queue[queueIndex++];
                
                if (current.dist >= maxRange) continue;
                
                const neighbors = [
                    {x: current.x - 1, y: current.y},
                    {x: current.x + 1, y: current.y},
                    {x: current.x, y: current.y - 1},
                    {x: current.x, y: current.y + 1}
                ];
                
                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= GRID_WIDTH || 
                        neighbor.y < 0 || neighbor.y >= GRID_HEIGHT) continue;
                    
                    if (distances[neighbor.y][neighbor.x] !== -1) continue;
                    
                    const cellType = grid[neighbor.y][neighbor.x];
                    if (cellType === 'road' || cellType === 'highway' || cellType === 'rail' || 
                        cellType === 'crossing' || cellType === 'residential' || cellType === 'commercial') {
                        
                        const moveCost = movementCosts[cellType] || 1.0;
                        const newDist = current.dist + moveCost;
                        
                        distances[neighbor.y][neighbor.x] = newDist;
                        if (newDist < maxRange) {
                            queue.push({x: neighbor.x, y: neighbor.y, dist: newDist});
                        }
                    }
                }
            }
            
            return distances;
        }
        
        function getMaxAccessRange(x, y) {
            let maxRange = 1; // ã‚¤ãƒ³ãƒ•ãƒ©ãªã—ãªã‚‰éš£æ¥1ãƒã‚¹ã®ã¿
            const adjacentCells = [
                {x: x-1, y: y}, {x: x+1, y: y},
                {x: x, y: y-1}, {x: x, y: y+1}
            ];
            
            for (let cell of adjacentCells) {
                if (cell.x >= 0 && cell.x < GRID_WIDTH && cell.y >= 0 && cell.y < GRID_HEIGHT) {
                    const adjacentType = grid[cell.y][cell.x];
                    if (accessRanges[adjacentType]) {
                        maxRange = Math.max(maxRange, accessRanges[adjacentType]);
                    }
                }
            }
            
            return maxRange;
        }
        
        
        function updateTaxDisplay() {
            document.getElementById('taxRevenue').textContent = Math.round(totalTaxRevenue).toLocaleString();
            document.getElementById('buildingCount').textContent = buildingCount;
            document.getElementById('highwayCount').textContent = highwayCount;
            document.getElementById('crossingCount').textContent = crossingCount;
            document.getElementById('clusterCount').textContent = getInfrastructureClusters();
            if (document.getElementById('iterationCount')) {
                document.getElementById('iterationCount').textContent = iterationCount;
            }
            if (document.getElementById('temperature') && autoPlayActive) {
                document.getElementById('temperature').textContent = getCurrentTemperature().toFixed(1);
            }
            
            // ç¨åå±¥æ­´ã‚’è¨˜éŒ²
            taxHistory.push(totalTaxRevenue);
            
            // å»ºç‰©æ•°å±¥æ­´ã‚’è¨˜éŒ²
            const buildingCounts = {
                residential: 0,
                commercial: 0,
                road: 0,
                highway: 0,
                rail: 0,
                crossing: 0
            };
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const buildingType = grid[y][x];
                    if (buildingCounts.hasOwnProperty(buildingType)) {
                        buildingCounts[buildingType]++;
                    }
                }
            }
            
            buildingHistory.push(buildingCounts);
            
            drawTaxChart();
            drawBuildingChart();
        }
        
        function drawTaxChart() {
            const canvas = document.getElementById('taxChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, width, height);
            
            if (taxHistory.length < 1) return;
            
            // æœ€å¤§å€¤ã¨æœ€å°å€¤ã‚’å–å¾—
            const maxRevenue = Math.max(...taxHistory);
            const minRevenue = Math.min(...taxHistory);
            const range = Math.max(maxRevenue - minRevenue, 1000);
            
            // ç›®ç››ã‚Šã‚’æç”»
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#bdc3c7';
            
            // Yè»¸ã®ç›®ç››ã‚Š
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (i / ySteps) * chartHeight;
                const value = maxRevenue - (i / ySteps) * range;
                
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                
                ctx.fillText('Â¥' + Math.round(value).toLocaleString(), 5, y + 4);
            }
            
            // Xè»¸ã®ç›®ç››ã‚Š
            const xSteps = Math.min(10, Math.max(1, Math.floor(taxHistory.length / 100)));
            const stepSize = Math.max(1, Math.floor(taxHistory.length / xSteps));
            for (let i = 0; i <= xSteps; i++) {
                const step = i * stepSize;
                if (step >= taxHistory.length) break;
                
                const x = padding + (step / Math.max(1, taxHistory.length - 1)) * chartWidth;
                
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + chartHeight);
                ctx.stroke();
                
                ctx.fillText(step.toString(), x - 10, height - 5);
            }
            
            // ã‚°ãƒ©ãƒ•ãƒ©ã‚¤ãƒ³ã‚’æç”»
            if (taxHistory.length > 1) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < taxHistory.length; i++) {
                    const x = padding + (i / Math.max(1, taxHistory.length - 1)) * chartWidth;
                    const y = padding + chartHeight - ((taxHistory[i] - minRevenue) / range) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
            
            // ç¾åœ¨ã®å€¤ã‚’è¡¨ç¤º
            if (taxHistory.length > 0) {
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                const lastX = padding + ((taxHistory.length - 1) / Math.max(1, taxHistory.length - 1)) * chartWidth;
                const lastY = padding + chartHeight - ((taxHistory[taxHistory.length - 1] - minRevenue) / range) * chartHeight;
                ctx.arc(lastX, lastY, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#ecf0f1';
            ctx.font = '14px Arial';
            ctx.fillText('ã‚¹ãƒ†ãƒƒãƒ—æ•°', width / 2 - 30, height - 20);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('ç¨å (Â¥)', -30, 0);
            ctx.restore();
        }

        function showSaveDialog() {
            const modal = document.getElementById('saveModal');
            const slotsDiv = document.getElementById('saveSlots');
            slotsDiv.innerHTML = '';
            
            for (let i = 1; i <= 3; i++) {
                const saveData = localStorage.getItem(`simcity_save_${i}`);
                const slot = document.createElement('div');
                slot.className = 'save-slot' + (saveData ? ' occupied' : '');
                
                let slotContent = `<strong>ã‚¹ãƒ­ãƒƒãƒˆ ${i}</strong>`;
                if (saveData) {
                    const data = JSON.parse(saveData);
                    slotContent += `<div class="slot-info">å»ºç‰©æ•°: ${data.buildingCount} | ç¨å: Â¥${data.totalTaxRevenue.toLocaleString()}/æœˆ<br>ä¿å­˜æ—¥æ™‚: ${data.timestamp}</div>`;
                } else {
                    slotContent += `<div class="slot-info">ç©ºã®ã‚¹ãƒ­ãƒƒãƒˆ</div>`;
                }
                
                slot.innerHTML = slotContent;
                slot.onclick = () => saveToSlot(i);
                slotsDiv.appendChild(slot);
            }
            
            modal.style.display = 'block';
        }
        
        function showLoadDialog() {
            const modal = document.getElementById('loadModal');
            const slotsDiv = document.getElementById('loadSlots');
            slotsDiv.innerHTML = '';
            
            for (let i = 1; i <= 3; i++) {
                const saveData = localStorage.getItem(`simcity_save_${i}`);
                const slot = document.createElement('div');
                slot.className = 'save-slot' + (saveData ? ' occupied' : '');
                
                let slotContent = `<strong>ã‚¹ãƒ­ãƒƒãƒˆ ${i}</strong>`;
                if (saveData) {
                    const data = JSON.parse(saveData);
                    slotContent += `<div class="slot-info">å»ºç‰©æ•°: ${data.buildingCount} | ç¨å: Â¥${data.totalTaxRevenue.toLocaleString()}/æœˆ<br>ä¿å­˜æ—¥æ™‚: ${data.timestamp}</div>`;
                    slot.onclick = () => loadFromSlot(i);
                } else {
                    slotContent += `<div class="slot-info">ç©ºã®ã‚¹ãƒ­ãƒƒãƒˆ</div>`;
                    slot.style.cursor = 'not-allowed';
                    slot.style.opacity = '0.5';
                }
                
                slot.innerHTML = slotContent;
                slotsDiv.appendChild(slot);
            }
            
            modal.style.display = 'block';
        }
        
        function closeSaveDialog() {
            document.getElementById('saveModal').style.display = 'none';
        }
        
        function closeLoadDialog() {
            document.getElementById('loadModal').style.display = 'none';
        }
        
        function saveToSlot(slotNumber) {
            const saveData = {
                grid: grid,
                totalTaxRevenue: totalTaxRevenue,
                buildingCount: buildingCount,
                highwayCount: highwayCount,
                timestamp: new Date().toLocaleString('ja-JP')
            };
            
            localStorage.setItem(`simcity_save_${slotNumber}`, JSON.stringify(saveData));
            alert(`ã‚¹ãƒ­ãƒƒãƒˆ ${slotNumber} ã«ä¿å­˜ã—ã¾ã—ãŸï¼`);
            closeSaveDialog();
        }
        
        function loadFromSlot(slotNumber) {
            const saveData = localStorage.getItem(`simcity_save_${slotNumber}`);
            if (!saveData) {
                alert('ã“ã®ã‚¹ãƒ­ãƒƒãƒˆã«ã¯ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            
            const data = JSON.parse(saveData);
            grid = data.grid;
            totalTaxRevenue = data.totalTaxRevenue;
            buildingCount = data.buildingCount;
            highwayCount = data.highwayCount;
            
            // ã‚°ãƒªãƒƒãƒ‰ã‚’å†æç”»
            const gameGrid = document.getElementById('gameGrid');
            gameGrid.innerHTML = '';
            
            const symbols = {
                residential: 'ğŸ ',
                commercial: 'ğŸ¢',
                road: 'â€”',
                rail: 'â•',
                highway: 'â”',
                crossing: 'â•¬'
            };
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (grid[y][x]) {
                        cell.className += ` ${grid[y][x]}`;
                        cell.textContent = symbols[grid[y][x]] || '';
                    }
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.onclick = () => placeBuilding(x, y);
                    
                    gameGrid.appendChild(cell);
                }
            }
            
            updateTaxDisplay();
            alert(`ã‚¹ãƒ­ãƒƒãƒˆ ${slotNumber} ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼`);
            closeLoadDialog();
        }
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const saveModal = document.getElementById('saveModal');
            const loadModal = document.getElementById('loadModal');
            if (event.target === saveModal) {
                closeSaveDialog();
            }
            if (event.target === loadModal) {
                closeLoadDialog();
            }
        }

        function toggleAutoPlay() {
            if (autoPlayActive) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }
        
        function startAutoPlay() {
            autoPlayActive = true;
            iterationCount = 0;
            document.getElementById('autoPlayBtn').textContent = 'è‡ªå‹•ãƒ—ãƒ¬ã‚¤åœæ­¢ â¹ï¸';
            document.getElementById('autoPlayBtn').style.backgroundColor = '#e74c3c';
            
            generateInitialCity();
            
            autoPlayInterval = setInterval(() => {
                if (iterationCount >= MAX_ITERATIONS) {
                    stopAutoPlay();
                    alert('è‡ªå‹•ãƒ—ãƒ¬ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸï¼50000å›åå¾©ã—ã¾ã—ãŸã€‚');
                    return;
                }
                
                optimizeCity();
                iterationCount++;
                document.getElementById('iterationCount').textContent = iterationCount;
            }, 100);
        }
        
        function stopAutoPlay() {
            autoPlayActive = false;
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            document.getElementById('autoPlayBtn').textContent = 'è‡ªå‹•ãƒ—ãƒ¬ã‚¤é–‹å§‹ ğŸ¤–';
            document.getElementById('autoPlayBtn').style.backgroundColor = '#8e44ad';
        }
        
        function generateInitialCity() {
            clearGrid();
            
            // é€£ç¶šã—ãŸã‚°ãƒªãƒƒãƒ‰çŠ¶ã®é“è·¯ã‚’é…ç½®ï¼ˆ5ãƒã‚¹é–“éš”ã§1ã¤ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä¿è¨¼ï¼‰
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (x % 5 === 0 || y % 5 === 0) {
                        placeAutoBuilding(x, y, 'road');
                    }
                }
            }
            
            // å…¨ã¦ã®ãƒã‚¹ã‚’åŸ‹ã‚ã‚‹ï¼ˆä½å®…ä¸­å¿ƒã€å•†æ¥­ã¯å°‘ãªã‚ã€é“è·¯è¿½åŠ ã¯æ§ãˆã‚ï¼‰
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === null) {  // é“è·¯ã§ãªã„å ´æ‰€ã«
                        let buildingType = null;
                        
                        if (Math.random() < 0.1) {
                            buildingType = 'road';  // æ—¢å­˜é“è·¯ç¶²ã¸ã®è¿½åŠ ã¯æ§ãˆã‚
                        } else if (Math.random() < 0.15) {
                            buildingType = 'commercial';
                        } else {
                            buildingType = 'residential';
                        }
                        
                        placeAutoBuilding(x, y, buildingType);
                    }
                }
            }
            
            // éƒ½å¸‚ä¸­å¿ƒéƒ¨ã«é«˜é€Ÿé“è·¯ã‚’é…ç½®
            const centerX = Math.floor(GRID_WIDTH / 2);
            const centerY = Math.floor(GRID_HEIGHT / 2);
            let highwayPlaced = 0;
            
            // ä¸­å¿ƒã®ç¸¦æ¨ªãƒ©ã‚¤ãƒ³
            for (let x = 0; x < GRID_WIDTH && highwayPlaced < MAX_HIGHWAYS; x++) {
                if (grid[centerY][x] === 'road') {
                    placeAutoBuilding(x, centerY, 'highway');
                    highwayPlaced++;
                }
            }
            
            for (let y = 0; y < GRID_HEIGHT && highwayPlaced < MAX_HIGHWAYS; y++) {
                if (grid[y][centerX] === 'road') {
                    placeAutoBuilding(centerX, y, 'highway');
                    highwayPlaced++;
                }
            }
            
            // ä¸­å¿ƒéƒ¨å‘¨è¾ºã®é“è·¯ã‚‚é«˜é€Ÿé“è·¯ã«ï¼ˆä¸­å¿ƒã‹ã‚‰5ãƒã‚¹ä»¥å†…ï¼‰
            for (let dy = -5; dy <= 5 && highwayPlaced < MAX_HIGHWAYS; dy++) {
                for (let dx = -5; dx <= 5 && highwayPlaced < MAX_HIGHWAYS; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                        if (grid[y][x] === 'road' && (x % 5 === 0 || y % 5 === 0)) {
                            placeAutoBuilding(x, y, 'highway');
                            highwayPlaced++;
                        }
                    }
                }
            }
            
            // ä¸€æœ¬ã®é‰„é“ç·šã‚’é…ç½®ï¼ˆç¸¦ã®ä¸»è¦è·¯ç·šï¼‰
            const railLineX = Math.floor(GRID_WIDTH / 4); // å·¦å´1/4ã®ä½ç½®
            for (let y = 0; y < GRID_HEIGHT; y++) {
                if (y % 5 === 0) {
                    // é“è·¯ã¨ã®äº¤å·®ç‚¹ã¯è¸åˆ‡ã«
                    placeAutoBuilding(railLineX, y, 'crossing');
                } else {
                    // ãã‚Œä»¥å¤–ã¯é‰„é“
                    placeAutoBuilding(railLineX, y, 'rail');
                }
            }
            
            // æ¨ªã®æ”¯ç·šé‰„é“ã‚’è¿½åŠ ï¼ˆä¸­å¤®ä»˜è¿‘ï¼‰
            const branchRailY = Math.floor(GRID_HEIGHT / 2);
            for (let x = railLineX; x < GRID_WIDTH; x += 10) {
                if (x % 5 === 0) {
                    // é“è·¯ã¨ã®äº¤å·®ç‚¹ã¯è¸åˆ‡ã«
                    placeAutoBuilding(x, branchRailY, 'crossing');
                } else {
                    // ãã‚Œä»¥å¤–ã¯é‰„é“
                    placeAutoBuilding(x, branchRailY, 'rail');
                }
            }
            
            calculateTaxRevenue();
            updateGrid();
        }
        
        function optimizeCity() {
            const currentRevenue = totalTaxRevenue;
            
            // ãƒ‡ãƒãƒƒã‚°: æœ€é©åŒ–å‰ã®å»ºç‰©æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            if (iterationCount % 1000 === 0) {
                const counts = countBuildings();
                console.log(`Step ${iterationCount}: ä½å®…=${counts.residential}, å•†æ¥­=${counts.commercial}, é“è·¯=${counts.road}, é«˜é€Ÿ=${counts.highway}, é‰„é“=${counts.rail}, è¸åˆ‡=${counts.crossing}`);
            }
            
            // 10%ã®ç¢ºç‡ã§4x4ã‚°ãƒªãƒƒãƒ‰ã‚’äº¤æ›
            if (Math.random() < 0.1) {
                swapGridRegions(currentRevenue);
            } else if (Math.random() < 0.3) {
                // 30%ã®ç¢ºç‡ã§éš£æ¥ã™ã‚‹2ãƒã‚¹ã‚’äº¤æ›
                swapAdjacentCells(currentRevenue);
            } else {
                // é€šå¸¸ã®2ãƒã‚¹å¤‰æ›´
                changeTwoCells(currentRevenue);
            }
        }
        
        function countBuildings() {
            const counts = {
                residential: 0,
                commercial: 0,
                road: 0,
                highway: 0,
                rail: 0,
                crossing: 0
            };
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const buildingType = grid[y][x];
                    if (counts.hasOwnProperty(buildingType)) {
                        counts[buildingType]++;
                    }
                }
            }
            
            return counts;
        }
        
        function swapGridRegions(currentRevenue) {
            // 4x4ã‚°ãƒªãƒƒãƒ‰ã‚’2ã¤é¸æŠã—ã¦ã‚¹ãƒ¯ãƒƒãƒ—
            const region1 = selectRandomRegion();
            const region2 = selectRandomRegion();
            
            // åŒã˜é ˜åŸŸã¯é¿ã‘ã‚‹
            if (region1.x === region2.x && region1.y === region2.y) {
                return;
            }
            
            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
            const savedRegion1 = [];
            const savedRegion2 = [];
            
            for (let dy = 0; dy < 4; dy++) {
                savedRegion1[dy] = [];
                savedRegion2[dy] = [];
                for (let dx = 0; dx < 4; dx++) {
                    const x1 = region1.x + dx;
                    const y1 = region1.y + dy;
                    const x2 = region2.x + dx;
                    const y2 = region2.y + dy;
                    
                    if (x1 < GRID_WIDTH && y1 < GRID_HEIGHT) {
                        savedRegion1[dy][dx] = grid[y1][x1];
                    }
                    if (x2 < GRID_WIDTH && y2 < GRID_HEIGHT) {
                        savedRegion2[dy][dx] = grid[y2][x2];
                    }
                }
            }
            
            // é«˜é€Ÿé“è·¯ã®æ•°ã‚’è¿½è·¡
            let highwayChange = 0;
            
            // é ˜åŸŸã‚’ã‚¹ãƒ¯ãƒƒãƒ—
            for (let dy = 0; dy < 4; dy++) {
                for (let dx = 0; dx < 4; dx++) {
                    const x1 = region1.x + dx;
                    const y1 = region1.y + dy;
                    const x2 = region2.x + dx;
                    const y2 = region2.y + dy;
                    
                    if (x1 < GRID_WIDTH && y1 < GRID_HEIGHT && x2 < GRID_WIDTH && y2 < GRID_HEIGHT) {
                        // é«˜é€Ÿé“è·¯ã®å¤‰æ›´ã‚’è¿½è·¡
                        if (savedRegion1[dy][dx] === 'highway') highwayChange--;
                        if (savedRegion2[dy][dx] === 'highway') highwayChange--;
                        if (savedRegion2[dy][dx] === 'highway') highwayChange++;
                        if (savedRegion1[dy][dx] === 'highway') highwayChange++;
                        
                        placeAutoBuilding(x1, y1, savedRegion2[dy][dx]);
                        placeAutoBuilding(x2, y2, savedRegion1[dy][dx]);
                    }
                }
            }
            
            calculateTaxRevenue();
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰ã‚¢ãƒ‹ãƒ¼ãƒªãƒ³ã‚°ï¼ˆæ¸©åº¦ã‚’100ã‹ã‚‰10ã¾ã§å†·å´ï¼‰
            const temperature = getCurrentTemperature();
            const revenueDiff = currentRevenue - totalTaxRevenue;
            const acceptanceProbability = revenueDiff > 0 ? Math.exp(-revenueDiff / temperature) : 1;
            
            if (totalTaxRevenue < currentRevenue && Math.random() > acceptanceProbability) {
                // å…ƒã«æˆ»ã™
                for (let dy = 0; dy < 4; dy++) {
                    for (let dx = 0; dx < 4; dx++) {
                        const x1 = region1.x + dx;
                        const y1 = region1.y + dy;
                        const x2 = region2.x + dx;
                        const y2 = region2.y + dy;
                        
                        if (x1 < GRID_WIDTH && y1 < GRID_HEIGHT && x2 < GRID_WIDTH && y2 < GRID_HEIGHT) {
                            placeAutoBuilding(x1, y1, savedRegion1[dy][dx]);
                            placeAutoBuilding(x2, y2, savedRegion2[dy][dx]);
                        }
                    }
                }
                calculateTaxRevenue();
            } else {
                // å¤‰æ›´ã‚’å—ã‘å…¥ã‚Œã‚‹ - è¦–è¦šçš„æ›´æ–°
                for (let dy = 0; dy < 4; dy++) {
                    for (let dx = 0; dx < 4; dx++) {
                        const x1 = region1.x + dx;
                        const y1 = region1.y + dy;
                        const x2 = region2.x + dx;
                        const y2 = region2.y + dy;
                        
                        if (x1 < GRID_WIDTH && y1 < GRID_HEIGHT) {
                            updateCellVisual(x1, y1);
                        }
                        if (x2 < GRID_WIDTH && y2 < GRID_HEIGHT) {
                            updateCellVisual(x2, y2);
                        }
                    }
                }
            }
        }
        
        function selectRandomRegion() {
            return {
                x: Math.floor(Math.random() * (GRID_WIDTH - 3)),
                y: Math.floor(Math.random() * (GRID_HEIGHT - 3))
            };
        }
        
        function getCurrentTemperature() {
            const progress = iterationCount / MAX_ITERATIONS;
            
            // ãƒ©ã‚¹ãƒˆ10%ã¯æ¸©åº¦1ï¼ˆã»ã¼ã‚°ãƒªãƒ¼ãƒ‡ã‚£ãƒ¼ï¼‰
            if (progress >= 0.9) {
                return 1;
            }
            
            // æœ€åˆã®90%ã§100 â†’ 10ã«ç·šå½¢å†·å´
            const adjustedProgress = progress / 0.9;
            const temperature = INITIAL_TEMPERATURE - (INITIAL_TEMPERATURE - FINAL_TEMPERATURE) * adjustedProgress;
            return Math.max(temperature, FINAL_TEMPERATURE);
        }
        
        function swapAdjacentCells(currentRevenue) {
            const adjacentPairs = [];
            
            // éš£æ¥ã™ã‚‹ã‚»ãƒ«ã®ãƒšã‚¢ã‚’åé›†
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // å³éš£
                    if (x + 1 < GRID_WIDTH) {
                        adjacentPairs.push([{x: x, y: y}, {x: x + 1, y: y}]);
                    }
                    // ä¸‹éš£
                    if (y + 1 < GRID_HEIGHT) {
                        adjacentPairs.push([{x: x, y: y}, {x: x, y: y + 1}]);
                    }
                }
            }
            
            if (adjacentPairs.length === 0) return;
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªéš£æ¥ãƒšã‚¢ã‚’é¸æŠ
            const randomPair = adjacentPairs[Math.floor(Math.random() * adjacentPairs.length)];
            const cell1 = randomPair[0];
            const cell2 = randomPair[1];
            
            const building1 = grid[cell1.y][cell1.x];
            const building2 = grid[cell2.y][cell2.x];
            
            // äº¤æ›
            placeAutoBuilding(cell1.x, cell1.y, building2);
            placeAutoBuilding(cell2.x, cell2.y, building1);
            calculateTaxRevenue();
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰ã‚¢ãƒ‹ãƒ¼ãƒªãƒ³ã‚°ï¼ˆæ¸©åº¦ã‚’100ã‹ã‚‰10ã¾ã§å†·å´ï¼‰
            const temperature = getCurrentTemperature();
            const revenueDiff = currentRevenue - totalTaxRevenue;
            const acceptanceProbability = revenueDiff > 0 ? Math.exp(-revenueDiff / temperature) : 1;
            
            if (totalTaxRevenue < currentRevenue && Math.random() > acceptanceProbability) {
                // å…ƒã«æˆ»ã™
                placeAutoBuilding(cell1.x, cell1.y, building1);
                placeAutoBuilding(cell2.x, cell2.y, building2);
                calculateTaxRevenue();
            } else {
                // å¤‰æ›´ã‚’å—ã‘å…¥ã‚Œã‚‹
                updateCellVisual(cell1.x, cell1.y);
                updateCellVisual(cell2.x, cell2.y);
            }
        }
        
        function changeTwoCells(currentRevenue) {
            // 2ã¤ã®ã‚»ãƒ«ã‚’é¸æŠ
            const cells = selectTwoCells();
            const cell1 = cells[0];
            const cell2 = cells[1];
            
            const currentBuilding1 = grid[cell1.y][cell1.x];
            const currentBuilding2 = grid[cell2.y][cell2.x];
            
            // æ–°ã—ã„å»ºç‰©ã‚¿ã‚¤ãƒ—ã‚’é¸æŠï¼ˆå•†æ¥­æ–½è¨­ã‚’å„ªå…ˆï¼‰
            let newBuilding1, newBuilding2;
            
            // 50%ã®ç¢ºç‡ã§å•†æ¥­æ–½è¨­ã«ç½®ãæ›ãˆ
            do {
                    newBuilding1 = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                } while (newBuilding1 === currentBuilding1);
            
            if (Math.random() < 0.5 && currentBuilding2 !== 'commercial') {
                newBuilding2 = 'commercial';
            } else {
                do {
                    newBuilding2 = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                } while (newBuilding2 === currentBuilding2);
            }
            
            // ãƒ‡ãƒãƒƒã‚°: å¤‰æ›´ã‚’ãƒ­ã‚°å‡ºåŠ›
            if (iterationCount % 1000 === 0) {
                console.log(`Changing (${cell1.x},${cell1.y}): ${currentBuilding1} -> ${newBuilding1}`);
                console.log(`Changing (${cell2.x},${cell2.y}): ${currentBuilding2} -> ${newBuilding2}`);
            }
            
            // é«˜é€Ÿé“è·¯ã¨è¸åˆ‡ã®åˆ¶é™ãƒã‚§ãƒƒã‚¯
            let highwayChange = 0;
            let crossingChange = 0;
            
            if (currentBuilding1 === 'highway') highwayChange--;
            if (currentBuilding2 === 'highway') highwayChange--;
            if (currentBuilding1 === 'crossing') crossingChange--;
            if (currentBuilding2 === 'crossing') crossingChange--;
            
            if (newBuilding1 === 'highway') highwayChange++;
            if (newBuilding2 === 'highway') highwayChange++;
            if (newBuilding1 === 'crossing') crossingChange++;
            if (newBuilding2 === 'crossing') crossingChange++;
            
            if (highwayCount + highwayChange > MAX_HIGHWAYS) {
                return;
            }
            
            if (crossingCount + crossingChange > MAX_CROSSINGS) {
                return;
            }
            
            // å¤‰æ›´ã‚’é©ç”¨
            placeAutoBuilding(cell1.x, cell1.y, newBuilding1);
            placeAutoBuilding(cell2.x, cell2.y, newBuilding2);
            calculateTaxRevenue();
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰ã‚¢ãƒ‹ãƒ¼ãƒªãƒ³ã‚°ï¼ˆæ¸©åº¦ã‚’100ã‹ã‚‰10ã¾ã§å†·å´ï¼‰
            const temperature = getCurrentTemperature();
            const revenueDiff = currentRevenue - totalTaxRevenue;
            const acceptanceProbability = revenueDiff > 0 ? Math.exp(-revenueDiff / temperature) : 1;
            
            if (totalTaxRevenue < currentRevenue && Math.random() > acceptanceProbability) {
                // å…ƒã«æˆ»ã™
                if (iterationCount % 1000 === 0) {
                    console.log(`Rejected: revenue ${currentRevenue} -> ${totalTaxRevenue}, probability ${acceptanceProbability.toFixed(3)}`);
                }
                placeAutoBuilding(cell1.x, cell1.y, currentBuilding1);
                placeAutoBuilding(cell2.x, cell2.y, currentBuilding2);
                calculateTaxRevenue();
            } else {
                // å¤‰æ›´ã‚’å—ã‘å…¥ã‚Œã‚‹
                if (iterationCount % 1000 === 0) {
                    console.log(`Accepted: revenue ${currentRevenue} -> ${totalTaxRevenue}, probability ${acceptanceProbability.toFixed(3)}`);
                }
                updateCellVisual(cell1.x, cell1.y);
                updateCellVisual(cell2.x, cell2.y);
            }
        }
        
        function selectTwoCells() {
            // ç©ºã‚»ãƒ«ï¼ˆnullï¼‰ã‚’å„ªå…ˆçš„ã«é¸æŠã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
            const emptyCells = [];
            const nonEmptyCells = [];

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === null) {
                        emptyCells.push({x, y});
                    } else {
                        nonEmptyCells.push({x, y});
                    }
                }
            }

            const cells = [];

            // ç©ºã‚»ãƒ«ãŒã‚ã‚‹å ´åˆã¯80%ã®ç¢ºç‡ã§ç©ºã‚»ãƒ«ã‚’é¸æŠ
            if (emptyCells.length > 0 && Math.random() < 0.8) {
                cells.push(emptyCells[Math.floor(Math.random() * emptyCells.length)]);
            } else if (nonEmptyCells.length > 0) {
                cells.push(nonEmptyCells[Math.floor(Math.random() * nonEmptyCells.length)]);
            } else {
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ 
                cells.push({
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                });
            }

            // 2ã¤ç›®ã®ã‚»ãƒ«ã‚’é¸æŠï¼ˆ1ã¤ç›®ã¨åŒã˜ã§ãªã„ã‚‚ã®ï¼‰
            let cell2;
            do {
                if (emptyCells.length > 1 && Math.random() < 0.8) {
                    cell2 = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                } else if (nonEmptyCells.length > 0) {
                    cell2 = nonEmptyCells[Math.floor(Math.random() * nonEmptyCells.length)];
                } else {
                    cell2 = {
                        x: Math.floor(Math.random() * GRID_WIDTH),
                        y: Math.floor(Math.random() * GRID_HEIGHT)
                    };
                }
            } while (cell2.x === cells[0].x && cell2.y === cells[0].y);
            cells.push(cell2);

            return cells;
        } 

        function placeAutoBuilding(x, y, buildingType) {
            if (grid[y][x] === 'highway') {
                highwayCount--;
            }
            if (grid[y][x] === 'crossing') {
                crossingCount--;
            }
            
            grid[y][x] = buildingType;
            
            if (buildingType === 'highway') {
                highwayCount++;
            }
            if (buildingType === 'crossing') {
                crossingCount++;
            }
        }
        
        function clearGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    grid[y][x] = null;
                }
            }
            highwayCount = 0;
            crossingCount = 0;
        }
        
        function updateGrid() {
            const gameGrid = document.getElementById('gameGrid');
            const cells = gameGrid.children;
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const index = y * GRID_WIDTH + x;
                    const cell = cells[index];
                    const buildingType = grid[y][x];
                    
                    cell.className = 'cell';
                    if (buildingType) {
                        cell.className += ` ${buildingType}`;
                        const symbols = {
                            residential: 'ğŸ ',
                            commercial: 'ğŸ¢',
                            road: 'â€”',
                            rail: 'â•',
                            highway: 'â”',
                            crossing: 'â•¬'
                        };
                        cell.textContent = symbols[buildingType] || '';
                    } else {
                        cell.textContent = '';
                    }
                }
            }
        }
        
        function updateCellVisual(x, y) {
            const index = y * GRID_WIDTH + x;
            const gameGrid = document.getElementById('gameGrid');
            const cell = gameGrid.children[index];
            const buildingType = grid[y][x];
            
            cell.className = 'cell';
            if (buildingType) {
                cell.className += ` ${buildingType}`;
                const symbols = {
                    residential: 'ğŸ ',
                    commercial: 'ğŸ¢',
                    road: 'â€”',
                    rail: 'â•',
                    highway: 'â”',
                    crossing: 'â•¬'
                };
                cell.textContent = symbols[buildingType] || '';
            } else {
                cell.textContent = '';
            }
        }

        function drawBuildingChart() {
            const canvas = document.getElementById('buildingChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, width, height);
            
            if (buildingHistory.length < 1) return;
            
            // æœ€å¤§å€¤ã‚’å–å¾—
            const buildingTypes = ['residential', 'commercial', 'road', 'highway', 'rail', 'crossing'];
            const colors = {
                residential: '#f39c12',
                commercial: '#9b59b6',
                road: '#7f8c8d',
                highway: '#2c3e50',
                rail: '#34495e',
                crossing: '#e67e22'
            };
            
            let maxCount = 0;
            for (const history of buildingHistory) {
                for (const type of buildingTypes) {
                    maxCount = Math.max(maxCount, history[type] || 0);
                }
            }
            
            // ç›®ç››ã‚Šã‚’æç”»
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#bdc3c7';
            
            // Yè»¸ã®ç›®ç››ã‚Š
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (i / ySteps) * chartHeight;
                const value = maxCount - (i / ySteps) * maxCount;
                
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                
                ctx.fillText(Math.round(value).toString(), 5, y + 4);
            }
            
            // Xè»¸ã®ç›®ç››ã‚Š
            const xSteps = Math.min(10, Math.max(1, Math.floor(buildingHistory.length / 100)));
            const stepSize = Math.max(1, Math.floor(buildingHistory.length / xSteps));
            for (let i = 0; i <= xSteps; i++) {
                const step = i * stepSize;
                if (step >= buildingHistory.length) break;
                
                const x = padding + (step / Math.max(1, buildingHistory.length - 1)) * chartWidth;
                
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + chartHeight);
                ctx.stroke();
                
                ctx.fillText(step.toString(), x - 10, height - 5);
            }
            
            // å„å»ºç‰©ã‚¿ã‚¤ãƒ—ã®ãƒ©ã‚¤ãƒ³ã‚’æç”»
            for (const buildingType of buildingTypes) {
                if (buildingHistory.length > 1) {
                    ctx.strokeStyle = colors[buildingType];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < buildingHistory.length; i++) {
                        const count = buildingHistory[i][buildingType] || 0;
                        const x = padding + (i / Math.max(1, buildingHistory.length - 1)) * chartWidth;
                        const y = padding + chartHeight - (count / maxCount) * chartHeight;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
            }
            
            // å‡¡ä¾‹ã‚’æç”»
            const legendX = width - 150;
            let legendY = padding + 20;
            ctx.font = '12px Arial';
            
            const buildingNames = {
                residential: 'ä½å®…',
                commercial: 'å•†æ¥­',
                road: 'é“è·¯',
                highway: 'é«˜é€Ÿ',
                rail: 'é‰„é“',
                crossing: 'è¸åˆ‡'
            };
            
            for (const buildingType of buildingTypes) {
                ctx.fillStyle = colors[buildingType];
                ctx.fillRect(legendX - 15, legendY - 8, 10, 10);
                
                ctx.fillStyle = '#ecf0f1';
                ctx.fillText(buildingNames[buildingType], legendX, legendY);
                
                legendY += 20;
            }
            
            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#ecf0f1';
            ctx.font = '14px Arial';
            ctx.fillText('ã‚¹ãƒ†ãƒƒãƒ—æ•°', width / 2 - 30, height - 20);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('å»ºç‰©æ•°', -30, 0);
            ctx.restore();
        }

        initializeGrid();
        calculateTaxRevenue();
        
        // åˆæœŸã‚°ãƒ©ãƒ•ã‚’æç”»
        setTimeout(() => {
            drawTaxChart();
            drawBuildingChart();
        }, 100);
        
        // åˆæœŸã‚°ãƒ©ãƒ•ã‚’æç”»
        setTimeout(() => {
            drawTaxChart();
        }, 100);
    </script>
</body>
</html>